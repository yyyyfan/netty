pipe管道, channel通道, buffer缓存, selector复用选择器
http
2.1 传统BIO，基本模型是Client/Server模型，也就是两个进程之间进行相互通信，服务端提供位置信息(绑定的ip地址和监听端口)，客户端通过连接操作向服务端监听的地址发起连接请求，通过三次握手建立连接，连接成功后，
    双方通过网络套接字(Socket)进行通信
    java中，ServerSocket负责绑定ip,启动监听端口；Socket负责发起连接操作。连接成功后，双方通过输入和输出流进行同步阻塞式通信
    socket.getTimeClient(), socket.getOutputStream(), socket.accept()
2.2 伪异步IO 通过创建线程池 ExecutorService, 将任务放置于线程池执行
    ExecutorService executor = new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors(), 50, 120L, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(10000));
    executor.execute(Runnable task);
2.3 java nio(non-block I/O),ServerSocketChannel/SOcketChannel
    缓冲区 buffer: capacity, limit, make, position, clear, flip
    通道 channel: 双全工(可以用于读、写或者读写同时进行)，而流只支持读或写
    多路复用器 selector: selector会不断轮询注册在其上的channel，
    服务器server
    1.打开 ServerSocketChannel; 2.绑定监听地址; 3.创建Selector,启动线程; 4.将ServerSocketChannel注册到Selector,监听; 5.Selector轮询就绪的Key; 6.handleAccept()处理新的客户端接入
    7.设置新建客户端连接的Socket参数; 8.向Selector注册监听读操作SelectionKey.OP_READ; 9.handleRead()异步请求消息到ByteBuffer; 10.decode请求信息; 11.异步写ByteBuffer到SocketChannel
    客户端client
    1.打开SocketChannel; 2.设置SocketChannel为非阻塞模式,同时设置TCP参数; 3.异步连接到服务器; 4.判断连接结果,如果连接成功,调到步骤10,否则执行步骤5; 5.向Reador线程的多路复用器注册OP_CONNECT; 6.创建Selector,启动线程；
    7.Selector轮询就绪的Key; 8.handerConnect(); 9.判断连接是否完成,完成执行步骤10; 10.向多路复用器注册读事件OP_READ; 11.handleRead()异步读请求到ByteBuffer; 12.decode请求信息; 13.异步写ByteBuffer到SocketChannel         
2.4 异步通信, 通过java.util.concurrent.Futrue来表示异步操作的结果，在执行异步操作的时候传入一个java.nio.channels; CompletionHandler接口的实现类作为操作完成的回调
    https://blog.csdn.net/xxb2008/article/details/42424105